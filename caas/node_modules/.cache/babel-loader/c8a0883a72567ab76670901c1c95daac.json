{"ast":null,"code":"\"use strict\";\n\nvar Shim = require(\"./shim\");\n\nvar Dict = require(\"./_dict\");\n\nvar List = require(\"./_list\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar GenericSet = require(\"./generic-set\");\n\nvar TreeLog = require(\"./tree-log\");\n\nvar object_has = Object.prototype.hasOwnProperty;\nmodule.exports = FastSet;\n\nfunction FastSet(values, equals, hash, getDefault) {\n  if (!(this instanceof FastSet)) {\n    return new FastSet(values, equals, hash, getDefault);\n  }\n\n  equals = equals || Object.equals;\n  hash = hash || Object.hash;\n  getDefault = getDefault || Function.noop;\n  this.contentEquals = equals;\n  this.contentHash = hash;\n  this.getDefault = getDefault;\n  var self = this;\n  this.buckets = new this.Buckets(null, function getDefaultBucket() {\n    return new self.Bucket();\n  });\n  this.length = 0;\n  this.addEach(values);\n}\n\nFastSet.FastSet = FastSet; // hack so require(\"fast-set\").FastSet will work in MontageJS\n\nObject.addEach(FastSet.prototype, GenericCollection.prototype);\nObject.addEach(FastSet.prototype, GenericSet.prototype);\nFastSet.from = GenericCollection.from;\nFastSet.prototype.Buckets = Dict;\nFastSet.prototype.Bucket = List;\n\nFastSet.prototype.constructClone = function (values) {\n  return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);\n};\n\nFastSet.prototype.has = function (value) {\n  var hash = this.contentHash(value);\n  return this.buckets.get(hash).has(value);\n};\n\nFastSet.prototype.get = function (value, equals) {\n  if (equals) {\n    throw new Error(\"FastSet#get does not support second argument: equals\");\n  }\n\n  var hash = this.contentHash(value);\n  var buckets = this.buckets;\n\n  if (buckets.has(hash)) {\n    return buckets.get(hash).get(value);\n  } else {\n    return this.getDefault(value);\n  }\n};\n\nFastSet.prototype[\"delete\"] = function (value, equals) {\n  if (equals) {\n    throw new Error(\"FastSet#delete does not support second argument: equals\");\n  }\n\n  var hash = this.contentHash(value);\n  var buckets = this.buckets;\n\n  if (buckets.has(hash)) {\n    var bucket = buckets.get(hash);\n\n    if (bucket[\"delete\"](value)) {\n      this.length--;\n\n      if (bucket.length === 0) {\n        buckets[\"delete\"](hash);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nFastSet.prototype.clear = function () {\n  this.buckets.clear();\n  this.length = 0;\n};\n\nFastSet.prototype.add = function (value) {\n  var hash = this.contentHash(value);\n  var buckets = this.buckets;\n\n  if (!buckets.has(hash)) {\n    buckets.set(hash, new this.Bucket(null, this.contentEquals));\n  }\n\n  if (!buckets.get(hash).has(value)) {\n    buckets.get(hash).add(value);\n    this.length++;\n    return true;\n  }\n\n  return false;\n};\n\nFastSet.prototype.reduce = function (callback, basis\n/*, thisp*/\n) {\n  var thisp = arguments[2];\n  var buckets = this.buckets;\n  var index = 0;\n  return buckets.reduce(function (basis, bucket) {\n    return bucket.reduce(function (basis, value) {\n      return callback.call(thisp, basis, value, index++, this);\n    }, basis, this);\n  }, basis, this);\n};\n\nFastSet.prototype.one = function () {\n  if (this.length > 0) {\n    return this.buckets.one().one();\n  }\n};\n\nFastSet.prototype.iterate = function () {\n  return this.buckets.valuesArray().flatten().iterate();\n};\n\nFastSet.prototype.log = function (charmap, logNode, callback, thisp) {\n  charmap = charmap || TreeLog.unicodeSharp;\n  logNode = logNode || this.logNode;\n\n  if (!callback) {\n    callback = console.log;\n    thisp = console;\n  }\n\n  callback = callback.bind(thisp);\n  var buckets = this.buckets,\n      bucketsSize = buckets.size,\n      mapIter = buckets.keys(),\n      hash,\n      index = 0,\n      branch,\n      leader,\n      bucket;\n\n  while (hash = mapIter.next().value) {\n    if (index === bucketsSize - 1) {\n      branch = charmap.fromAbove;\n      leader = ' ';\n    } else if (index === 0) {\n      branch = charmap.branchDown;\n      leader = charmap.strafe;\n    } else {\n      branch = charmap.fromBoth;\n      leader = charmap.strafe;\n    }\n\n    bucket = buckets.get(hash);\n    callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash);\n    bucket.forEach(function (value, node) {\n      var branch, below, written;\n\n      if (node === bucket.head.prev) {\n        branch = charmap.fromAbove;\n        below = ' ';\n      } else {\n        branch = charmap.fromBoth;\n        below = charmap.strafe;\n      }\n\n      logNode(node, function (line) {\n        if (!written) {\n          callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line);\n          written = true;\n        } else {\n          callback.call(thisp, leader + ' ' + below + '  ' + line);\n        }\n      }, function (line) {\n        callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);\n      });\n    });\n    index++;\n  } //var hashes = buckets.keysArray();\n  // hashes.forEach(function (hash, index) {\n  //     var branch;\n  //     var leader;\n  //     if (index === hashes.length - 1) {\n  //         branch = charmap.fromAbove;\n  //         leader = ' ';\n  //     } else if (index === 0) {\n  //         branch = charmap.branchDown;\n  //         leader = charmap.strafe;\n  //     } else {\n  //         branch = charmap.fromBoth;\n  //         leader = charmap.strafe;\n  //     }\n  //     var bucket = buckets.get(hash);\n  //     callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash);\n  //     bucket.forEach(function (value, node) {\n  //         var branch, below;\n  //         if (node === bucket.head.prev) {\n  //             branch = charmap.fromAbove;\n  //             below = ' ';\n  //         } else {\n  //             branch = charmap.fromBoth;\n  //             below = charmap.strafe;\n  //         }\n  //         var written;\n  //         logNode(\n  //             node,\n  //             function (line) {\n  //                 if (!written) {\n  //                     callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line);\n  //                     written = true;\n  //                 } else {\n  //                     callback.call(thisp, leader + ' ' + below + '  ' + line);\n  //                 }\n  //             },\n  //             function (line) {\n  //                 callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);\n  //             }\n  //         );\n  //     });\n  // });\n\n};\n\nFastSet.prototype.logNode = function (node, write) {\n  var value = node.value;\n\n  if (Object(value) === value) {\n    JSON.stringify(value, null, 4).split(\"\\n\").forEach(function (line) {\n      write(\" \" + line);\n    });\n  } else {\n    write(\" \" + value);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}