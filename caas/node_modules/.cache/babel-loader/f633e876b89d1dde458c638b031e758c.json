{"ast":null,"code":"\"use strict\";\n\nvar Shim = require(\"./shim\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar Map, GlobalMap, CollectionsMap;\n\nif (global.Map !== void 0 && typeof global.Set.prototype.values === \"function\") {\n  Map = module.exports = global.Map, GlobalMap = Map;\n  Map.Map = Map; // hack so require(\"map\").Map will work in MontageJS\n  // use different strategies for making sets observable between Internet\n  // Explorer and other browsers.\n\n  var protoIsSupported = {}.__proto__ === Object.prototype,\n      map_makeObservable;\n\n  if (protoIsSupported) {\n    map_makeObservable = function map_makeObservable() {\n      this.__proto__ = ChangeDispatchMap;\n    };\n  } else {\n    map_makeObservable = function map_makeObservable() {\n      Object.defineProperties(this, observableSetProperties);\n    };\n  }\n\n  Object.defineProperty(Map.prototype, \"makeObservable\", {\n    value: map_makeObservable,\n    writable: true,\n    configurable: true,\n    enumerable: false\n  }); //This is a no-op test in property-changes.js - PropertyChanges.prototype.makePropertyObservable, so might as well not pay the price every time....\n\n  Object.defineProperty(Map.prototype, \"makePropertyObservable\", {\n    value: function value() {},\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n\n  Map.prototype.constructClone = function (values) {\n    return new this.constructor(values);\n  };\n\n  Map.prototype.isMap = true;\n\n  Map.prototype.addEach = function (values) {\n    if (values && Object(values) === values) {\n      if (typeof values.forEach === \"function\") {\n        // copy map-alikes\n        if (values.isMap === true) {\n          values.forEach(function (value, key) {\n            this.set(key, value);\n          }, this); // iterate key value pairs of other iterables\n        } else {\n          values.forEach(function (pair) {\n            this.set(pair[0], pair[1]);\n          }, this);\n        }\n      } else if (typeof values.length === \"number\") {\n        // Array-like objects that do not implement forEach, ergo,\n        // Arguments\n        for (var i = 0; i < values.length; i++) {\n          this.add(values[i], i);\n        }\n      } else {\n        // copy other objects as map-alikes\n        Object.keys(values).forEach(function (key) {\n          this.set(key, values[key]);\n        }, this);\n      }\n    } else if (values && typeof values.length === \"number\") {\n      // String\n      for (var i = 0; i < values.length; i++) {\n        this.add(values[i], i);\n      }\n    }\n\n    return this;\n  };\n\n  Map.prototype.add = function (value, key) {\n    return this.set(key, value);\n  };\n\n  Map.prototype.reduce = function (callback, basis\n  /*, thisp*/\n  ) {\n    var thisp = arguments[2];\n    this.forEach(function (value, key, map) {\n      basis = callback.call(thisp, basis, value, key, this);\n    });\n    return basis;\n  };\n\n  Map.prototype.reduceRight = function (callback, basis\n  /*, thisp*/\n  ) {\n    var thisp = arguments[2];\n    var keysIterator = this.keys();\n    var size = this.size;\n    var reverseOrder = new Array(this.size);\n    var aKey,\n        i = 0;\n\n    while (aKey = keysIterator.next().value) {\n      reverseOrder[--size] = aKey;\n    }\n\n    while (i++ < size) {\n      basis = callback.call(thisp, basis, this.get(reverseOrder[i]), reverseOrder[i], this);\n    }\n\n    return basis;\n  };\n\n  Map.prototype.equals = function (that, equals) {\n    equals = equals || Object.equals;\n\n    if (this === that) {\n      return true;\n    } else if (that && typeof that.every === \"function\") {\n      return that.size === this.size && that.every(function (value, key) {\n        return equals(this.get(key), value);\n      }, this);\n    } else {\n      var keys = Object.keys(that);\n      return keys.length === this.size && Object.keys(that).every(function (key) {\n        return equals(this.get(key), that[key]);\n      }, this);\n    }\n  };\n\n  var _keysArrayFunction = function _keysArrayFunction(value, key) {\n    return key;\n  };\n\n  Map.prototype.keysArray = function () {\n    return this.map(_keysArrayFunction);\n  };\n\n  var _valuesArrayFunction = function _valuesArrayFunction(value, key) {\n    return value;\n  };\n\n  Map.prototype.valuesArray = function () {\n    return this.map(_valuesArrayFunction);\n  };\n\n  var _entriesArrayFunction = function _entriesArrayFunction(value, key) {\n    return [key, value];\n  };\n\n  Map.prototype.entriesArray = function () {\n    return this.map(_entriesArrayFunction);\n  };\n\n  Map.prototype.toJSON = function () {\n    return this.entriesArray();\n  }; // XXX deprecated\n\n\n  Map.prototype.items = function () {\n    return this.entriesArray();\n  }; // Map.prototype.contentEquals = Object.equals;\n  // Map.prototype.contentHash = Object.hash;\n\n\n  Map.from = function (value) {\n    var result = new this();\n    result.addEach(value);\n    return result;\n  }; //Backward compatibility:\n\n\n  Object.defineProperty(Map.prototype, \"length\", {\n    get: function get() {\n      return this.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  var map_clear = Map.prototype.clear,\n      map_set = Map.prototype.set,\n      map_delete = Map.prototype.delete;\n  var observableMapProperties = {\n    clear: {\n      value: function value() {\n        var keys;\n\n        if (this.dispatchesMapChanges) {\n          this.forEach(function (value, key) {\n            this.dispatchBeforeMapChange(key, value);\n          }, this);\n          keys = this.keysArray();\n        }\n\n        map_clear.call(this);\n\n        if (this.dispatchesMapChanges) {\n          keys.forEach(function (key) {\n            this.dispatchMapChange(key);\n          }, this);\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    set: {\n      value: function value(key, _value) {\n        var found = this.get(key);\n\n        if (found) {\n          // update\n          if (this.dispatchesMapChanges) {\n            this.dispatchBeforeMapChange(key, found);\n          }\n\n          map_set.call(this, key, _value);\n\n          if (this.dispatchesMapChanges) {\n            this.dispatchMapChange(key, _value);\n          }\n        } else {\n          // create\n          if (this.dispatchesMapChanges) {\n            this.dispatchBeforeMapChange(key, undefined);\n          }\n\n          map_set.call(this, key, _value);\n\n          if (this.dispatchesMapChanges) {\n            this.dispatchMapChange(key, _value);\n          }\n        }\n\n        return this;\n      },\n      writable: true,\n      configurable: true\n    },\n    \"delete\": {\n      value: function value(key) {\n        if (this.has(key)) {\n          if (this.dispatchesMapChanges) {\n            this.dispatchBeforeMapChange(key, this.get(key));\n          }\n\n          map_delete.call(this, key);\n\n          if (this.dispatchesMapChanges) {\n            this.dispatchMapChange(key, undefined);\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n    }\n  };\n  Object.addEach(Map.prototype, GenericCollection.prototype, false);\n  var ChangeDispatchMap = Object.create(Map.prototype, observableMapProperties);\n}\n\nvar Set = require(\"./_set\").CollectionsSet;\n\nvar GenericMap = require(\"./generic-map\");\n\nCollectionsMap = Map = function Map(values, equals, hash, getDefault) {\n  if (!(this instanceof Map)) {\n    return new Map(values, equals, hash, getDefault);\n  }\n\n  equals = equals || Object.equals;\n  hash = hash || Object.hash;\n  getDefault = getDefault || Function.noop;\n  this.contentEquals = equals;\n  this.contentHash = hash;\n  this.getDefault = getDefault;\n  this.store = new Set(undefined, function keysEqual(a, b) {\n    return equals(a.key, b.key);\n  }, function keyHash(item) {\n    return hash(item.key);\n  });\n  this.length = 0;\n  this.addEach(values);\n};\n\nMap.Map = Map; // hack so require(\"map\").Map will work in MontageJS\n\nObject.addEach(Map.prototype, GenericCollection.prototype);\nObject.addEach(Map.prototype, GenericMap.prototype); // overrides GenericCollection\n\nObject.defineProperty(Map.prototype, \"size\", GenericCollection._sizePropertyDescriptor);\nMap.from = GenericCollection.from;\n\nMap.prototype.constructClone = function (values) {\n  return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);\n};\n\nMap.prototype.log = function (charmap, logNode, callback, thisp) {\n  logNode = logNode || this.logNode;\n  this.store.log(charmap, function (node, log, logBefore) {\n    logNode(node.value.value, log, logBefore);\n  }, callback, thisp);\n};\n\nMap.prototype.logNode = function (node, log) {\n  log(' key: ' + node.key);\n  log(' value: ' + node.value);\n};\n\nif (!GlobalMap) {\n  module.exports = CollectionsMap;\n} else {\n  module.exports = GlobalMap;\n  GlobalMap.CollectionsMap = CollectionsMap;\n}","map":null,"metadata":{},"sourceType":"script"}