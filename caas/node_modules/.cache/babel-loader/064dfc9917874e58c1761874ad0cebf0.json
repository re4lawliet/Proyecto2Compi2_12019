{"ast":null,"code":"\"use strict\";\n\nvar Shim = require(\"./shim\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar GenericSet = require(\"./generic-set\");\n\nvar Set, GlobalSet, CollectionsSet;\n\nif (global.Set !== void 0 && typeof global.Set.prototype.values === \"function\") {\n  GlobalSet = module.exports = global.Set;\n  GlobalSet.Set = GlobalSet; // hack so require(\"set\").Set will work in MontageJS\n\n  GlobalSet.prototype.reduce = function (callback, basis\n  /*, thisp*/\n  ) {\n    var thisp = arguments[2];\n    this.forEach(function (value) {\n      basis = callback.call(thisp, basis, value, this);\n    });\n    return basis;\n  };\n\n  GlobalSet.prototype.reduceRight = function (callback, basis\n  /*, thisp*/\n  ) {\n    var thisp = arguments[2];\n    var setIterator = this.values();\n    var size = this.size;\n    var reverseOrder = new Array(this.size);\n    var value,\n        i = size; // Fill 'reverseOrder' with values of Set in inverted order.\n\n    while (value = setIterator.next().value) {\n      reverseOrder[--i] = value;\n    } // Iterate over reversed values and callback.\n\n\n    while (i < size) {\n      basis = callback.call(thisp, basis, reverseOrder[i++], this);\n    }\n\n    return basis;\n  };\n\n  GlobalSet.prototype.equals = function (that, equals) {\n    var self = this;\n    return that && typeof that.reduce === \"function\" && this.size === (that.size || that.length) && that.reduce(function (equal, value) {\n      return equal && self.has(value, equals);\n    }, true);\n  };\n\n  GlobalSet.prototype.constructClone = function (values) {\n    return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);\n  };\n\n  GlobalSet.prototype.toJSON = function () {\n    return this.entriesArray();\n  };\n\n  GlobalSet.prototype.one = function () {\n    if (this.size > 0) {\n      return this.values().next().value;\n    }\n\n    return undefined;\n  };\n\n  GlobalSet.prototype.pop = function () {\n    if (this.size) {\n      var setIterator = this.values(),\n          aValue,\n          value;\n\n      while (aValue = setIterator.next().value) {\n        value = aValue;\n      }\n\n      this[\"delete\"](value, this.size - 1);\n      return value;\n    }\n  };\n\n  GlobalSet.prototype.shift = function () {\n    if (this.size) {\n      var firstValue = this.values().next().value;\n      this[\"delete\"](firstValue, 0);\n      return firstValue;\n    }\n  }; //Backward compatibility:\n\n\n  Object.defineProperty(GlobalSet.prototype, \"length\", {\n    get: function get() {\n      return this.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GlobalSet.from = function (value) {\n    var result = new this();\n    result.addEach(value);\n    return result;\n  };\n\n  Object.addEach(GlobalSet.prototype, GenericCollection.prototype, false);\n  Object.addEach(GlobalSet.prototype, GenericSet.prototype, false);\n}\n\nvar List = require(\"./_list\");\n\nvar FastSet = require(\"./_fast-set\");\n\nvar Iterator = require(\"./iterator\");\n\nCollectionsSet = function CollectionsSet(values, equals, hash, getDefault) {\n  return CollectionsSet._init(CollectionsSet, this, values, equals, hash, getDefault);\n};\n\nCollectionsSet._init = function (constructor, object, values, equals, hash, getDefault) {\n  if (!(object instanceof constructor)) {\n    return new constructor(values, equals, hash, getDefault);\n  }\n\n  equals = equals || Object.equals;\n  hash = hash || Object.hash;\n  getDefault = getDefault || Function.noop;\n  object.contentEquals = equals;\n  object.contentHash = hash;\n  object.getDefault = getDefault; // a list of values in insertion order, used for all operations that depend\n  // on iterating in insertion order\n\n  object.order = new object.Order(undefined, equals); // a set of nodes from the order list, indexed by the corresponding value,\n  // used for all operations that need to quickly seek  value in the list\n\n  object.store = new object.Store(undefined, function (a, b) {\n    return equals(a.value, b.value);\n  }, function (node) {\n    return hash(node.value);\n  });\n  object.length = 0;\n  object.addEach(values);\n};\n\nCollectionsSet.Set = CollectionsSet; // hack so require(\"set\").Set will work in MontageJS\n\nCollectionsSet.CollectionsSet = CollectionsSet;\nObject.addEach(CollectionsSet.prototype, GenericCollection.prototype);\nObject.addEach(CollectionsSet.prototype, GenericSet.prototype);\nCollectionsSet.from = GenericCollection.from;\nObject.defineProperty(CollectionsSet.prototype, \"size\", GenericCollection._sizePropertyDescriptor); //Overrides for consistency:\n// Set.prototype.forEach = GenericCollection.prototype.forEach;\n\nCollectionsSet.prototype.Order = List;\nCollectionsSet.prototype.Store = FastSet;\n\nCollectionsSet.prototype.constructClone = function (values) {\n  return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);\n};\n\nCollectionsSet.prototype.has = function (value) {\n  var node = new this.order.Node(value);\n  return this.store.has(node);\n};\n\nCollectionsSet.prototype.get = function (value, equals) {\n  if (equals) {\n    throw new Error(\"Set#get does not support second argument: equals\");\n  }\n\n  var node = new this.order.Node(value);\n  node = this.store.get(node);\n\n  if (node) {\n    return node.value;\n  } else {\n    return this.getDefault(value);\n  }\n};\n\nCollectionsSet.prototype.add = function (value) {\n  var node = new this.order.Node(value);\n\n  if (!this.store.has(node)) {\n    var index = this.length;\n    this.order.add(value);\n    node = this.order.head.prev;\n    this.store.add(node);\n    this.length++;\n    return true;\n  }\n\n  return false;\n};\n\nCollectionsSet.prototype[\"delete\"] = function (value, equals) {\n  if (equals) {\n    throw new Error(\"Set#delete does not support second argument: equals\");\n  }\n\n  var node = new this.order.Node(value);\n\n  if (this.store.has(node)) {\n    node = this.store.get(node);\n    this.store[\"delete\"](node); // removes from the set\n\n    this.order.splice(node, 1); // removes the node from the list\n\n    this.length--;\n    return true;\n  }\n\n  return false;\n};\n\nCollectionsSet.prototype.pop = function () {\n  if (this.length) {\n    var result = this.order.head.prev.value;\n    this[\"delete\"](result);\n    return result;\n  }\n};\n\nCollectionsSet.prototype.shift = function () {\n  if (this.length) {\n    var result = this.order.head.next.value;\n    this[\"delete\"](result);\n    return result;\n  }\n};\n\nCollectionsSet.prototype.one = function () {\n  if (this.length > 0) {\n    return this.store.one().value;\n  }\n};\n\nCollectionsSet.prototype.clear = function () {\n  this.store.clear();\n  this.order.clear();\n  this.length = 0;\n};\n\nObject.defineProperty(CollectionsSet.prototype, \"_clear\", {\n  value: CollectionsSet.prototype.clear\n});\n\nCollectionsSet.prototype.reduce = function (callback, basis\n/*, thisp*/\n) {\n  var thisp = arguments[2];\n  var list = this.order;\n  var index = 0;\n  return list.reduce(function (basis, value) {\n    return callback.call(thisp, basis, value, index++, this);\n  }, basis, this);\n};\n\nCollectionsSet.prototype.reduceRight = function (callback, basis\n/*, thisp*/\n) {\n  var thisp = arguments[2];\n  var list = this.order;\n  var index = this.length - 1;\n  return list.reduceRight(function (basis, value) {\n    return callback.call(thisp, basis, value, index--, this);\n  }, basis, this);\n};\n\nCollectionsSet.prototype.iterate = function () {\n  return this.order.iterate();\n};\n\nCollectionsSet.prototype.values = function () {\n  return new Iterator(this.valuesArray());\n};\n\nCollectionsSet.prototype.log = function () {\n  var set = this.store;\n  return set.log.apply(set, arguments);\n};\n\nif (!GlobalSet) {\n  module.exports = CollectionsSet;\n} else {\n  GlobalSet.prototype.valuesArray = GenericSet.prototype.valuesArray;\n  GlobalSet.prototype.entriesArray = GenericSet.prototype.entriesArray;\n  module.exports = GlobalSet;\n  GlobalSet.CollectionsSet = CollectionsSet;\n}","map":null,"metadata":{},"sourceType":"script"}