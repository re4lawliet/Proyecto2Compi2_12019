{"ast":null,"code":"\"use strict\"; //TODO:\n// Remove Dict and use native Map as much as possible here\n//Use ObjectChangeDescriptor to avoid creating useless arrays and benefit from similar gains made in property-changes\n\nvar WeakMap = require(\"../weak-map\"),\n    Map = require(\"../_map\"),\n    ChangeDescriptor = require(\"./change-descriptor\"),\n    ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor,\n    ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord,\n    ListenerGhost = ChangeDescriptor.ListenerGhost;\n\nvar rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}\n//\n\nfunction RangeChangeDescriptor(name) {\n  this.name = name;\n  this.isActive = false;\n  this._willChangeListeners = null;\n  this._changeListeners = null;\n}\n\n;\nRangeChangeDescriptor.prototype = new ObjectChangeDescriptor();\nRangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor;\nRangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord;\nRangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord;\nObject.defineProperty(RangeChangeDescriptor.prototype, \"active\", {\n  get: function get() {\n    return this._active || (this._active = this._current ? this._current.slice() : []);\n  }\n});\nvar RangeChangeListenersSpecificHandlerMethodName = new Map();\n\nfunction RangeChangeListenersRecord(name) {\n  var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);\n\n  if (!specificHandlerMethodName) {\n    specificHandlerMethodName = \"handle\";\n    specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n    specificHandlerMethodName += name.slice(1);\n    specificHandlerMethodName += \"RangeChange\";\n    RangeChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName);\n  }\n\n  this.specificHandlerMethodName = specificHandlerMethodName;\n  return this;\n}\n\nRangeChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;\nvar RangeWillChangeListenersSpecificHandlerMethodName = new Map();\n\nfunction RangeWillChangeListenersRecord(name) {\n  var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);\n\n  if (!specificHandlerMethodName) {\n    specificHandlerMethodName = \"handle\";\n    specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n    specificHandlerMethodName += name.slice(1);\n    specificHandlerMethodName += \"RangeWillChange\";\n    RangeWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName);\n  }\n\n  this.specificHandlerMethodName = specificHandlerMethodName;\n  return this;\n}\n\nRangeWillChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord;\nmodule.exports = RangeChanges;\n\nfunction RangeChanges() {\n  throw new Error(\"Can't construct. RangeChanges is a mixin.\");\n}\n\nRangeChanges.prototype.getAllRangeChangeDescriptors = function () {\n  if (!rangeChangeDescriptors.has(this)) {\n    rangeChangeDescriptors.set(this, new Map());\n  }\n\n  return rangeChangeDescriptors.get(this);\n};\n\nRangeChanges.prototype.getRangeChangeDescriptor = function (token) {\n  var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();\n  token = token || \"\";\n\n  if (!tokenChangeDescriptors.has(token)) {\n    tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token));\n  }\n\n  return tokenChangeDescriptors.get(token);\n};\n\nvar ObjectsDispatchesRangeChanges = new WeakMap(),\n    dispatchesRangeChangesGetter = function dispatchesRangeChangesGetter() {\n  return ObjectsDispatchesRangeChanges.get(this);\n},\n    dispatchesRangeChangesSetter = function dispatchesRangeChangesSetter(value) {\n  return ObjectsDispatchesRangeChanges.set(this, value);\n},\n    dispatchesChangesMethodName = \"dispatchesRangeChanges\",\n    dispatchesChangesPropertyDescriptor = {\n  get: dispatchesRangeChangesGetter,\n  set: dispatchesRangeChangesSetter,\n  configurable: true,\n  enumerable: false\n};\n\nRangeChanges.prototype.addRangeChangeListener = function addRangeChangeListener(listener, token, beforeChange) {\n  // a concession for objects like Array that are not inherently observable\n  if (!this.isObservable && this.makeObservable) {\n    this.makeObservable();\n  }\n\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n\n  if (beforeChange) {\n    listeners = descriptor.willChangeListeners;\n  } else {\n    listeners = descriptor.changeListeners;\n  } // even if already registered\n\n\n  if (!listeners._current) {\n    listeners._current = listener;\n  } else if (!Array.isArray(listeners._current)) {\n    listeners._current = [listeners._current, listener];\n  } else {\n    listeners._current.push(listener);\n  }\n\n  if (Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), dispatchesChangesMethodName) === void 0) {\n    Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), dispatchesChangesMethodName, dispatchesChangesPropertyDescriptor);\n  }\n\n  this.dispatchesRangeChanges = true;\n  var self = this;\n  return function cancelRangeChangeListener() {\n    if (!self) {\n      // TODO throw new Error(\"Range change listener \" + JSON.stringify(token) + \" has already been canceled\");\n      return;\n    }\n\n    self.removeRangeChangeListener(listener, token, beforeChange);\n    self = null;\n  };\n};\n\nRangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n\n  if (beforeChange) {\n    listeners = descriptor._willChangeListeners;\n  } else {\n    listeners = descriptor._changeListeners;\n  }\n\n  if (listeners._current) {\n    if (listeners._current === listener) {\n      listeners._current = null;\n    } else {\n      var index = listeners._current.lastIndexOf(listener);\n\n      if (index === -1) {\n        throw new Error(\"Can't remove range change listener: does not exist: token \" + JSON.stringify(token));\n      } else {\n        if (descriptor.isActive) {\n          listeners.ghostCount = listeners.ghostCount + 1;\n          listeners._current[index] = ListenerGhost;\n        } else {\n          listeners._current.spliceOne(index);\n        }\n      }\n    }\n  }\n};\n\nRangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {\n  var descriptors = this.getAllRangeChangeDescriptors(),\n      descriptor,\n      mapIter = descriptors.values(),\n      listeners,\n      tokenName,\n      i,\n      countI,\n      listener,\n      currentListeners,\n      Ghost;\n  descriptors.dispatchBeforeChange = beforeChange;\n\n  while (descriptor = mapIter.next().value) {\n    if (descriptor.isActive) {\n      return;\n    } // before or after\n\n\n    listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;\n\n    if (listeners && listeners._current) {\n      tokenName = listeners.specificHandlerMethodName;\n\n      if (Array.isArray(listeners._current)) {\n        if (listeners._current.length) {\n          // notably, defaults to \"handleRangeChange\" or \"handleRangeWillChange\"\n          // if token is \"\" (the default)\n          descriptor.isActive = true; // dispatch each listener\n\n          try {\n            //removeGostListenersIfNeeded returns listeners.current or a new filtered one when conditions are met\n            currentListeners = listeners.removeCurrentGostListenersIfNeeded();\n            Ghost = ListenerGhost;\n\n            for (i = 0, countI = currentListeners.length; i < countI; i++) {\n              if ((listener = currentListeners[i]) !== Ghost) {\n                if (listener[tokenName]) {\n                  listener[tokenName](plus, minus, index, this, beforeChange);\n                } else if (listener.call) {\n                  listener.call(this, plus, minus, index, this, beforeChange);\n                } else {\n                  throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n                }\n              }\n            }\n          } finally {\n            descriptor.isActive = false;\n          }\n        }\n      } else {\n        descriptor.isActive = true; // dispatch each listener\n\n        try {\n          listener = listeners._current;\n\n          if (listener[tokenName]) {\n            listener[tokenName](plus, minus, index, this, beforeChange);\n          } else if (listener.call) {\n            listener.call(this, plus, minus, index, this, beforeChange);\n          } else {\n            throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n          }\n        } finally {\n          descriptor.isActive = false;\n        }\n      }\n    }\n  }\n};\n\nRangeChanges.prototype.addBeforeRangeChangeListener = function (listener, token) {\n  return this.addRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {\n  return this.removeRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {\n  return this.dispatchRangeChange(plus, minus, index, true);\n};","map":null,"metadata":{},"sourceType":"script"}