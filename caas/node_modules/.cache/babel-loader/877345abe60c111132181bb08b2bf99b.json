{"ast":null,"code":"\"use strict\";\n/*\n    Based in part on extras from Motorola Mobility’s Montage\n    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.\n    3-Clause BSD License\n    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md\n*/\n\nvar Function = require(\"./shim-function\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar GenericOrder = require(\"./generic-order\");\n\nvar WeakMap = require(\"./weak-map\");\n\nmodule.exports = Array;\nvar array_splice = Array.prototype.splice;\nvar array_slice = Array.prototype.slice;\nArray.empty = [];\n\nif (Object.freeze) {\n  Object.freeze(Array.empty);\n}\n\nArray.from = function (values) {\n  var array = [];\n  array.addEach(values);\n  return array;\n};\n\nArray.unzip = function (table) {\n  var transpose = [];\n  var length = Infinity; // compute shortest row\n\n  for (var i = 0; i < table.length; i++) {\n    var row = table[i];\n    table[i] = row.toArray();\n\n    if (row.length < length) {\n      length = row.length;\n    }\n  }\n\n  for (var i = 0; i < table.length; i++) {\n    var row = table[i];\n\n    for (var j = 0; j < row.length; j++) {\n      if (j < length && j in row) {\n        transpose[j] = transpose[j] || [];\n        transpose[j][i] = row[j];\n      }\n    }\n  }\n\n  return transpose;\n};\n\nfunction define(key, value) {\n  Object.defineProperty(Array.prototype, key, {\n    value: value,\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n}\n\ndefine(\"addEach\", GenericCollection.prototype.addEach);\ndefine(\"deleteEach\", GenericCollection.prototype.deleteEach);\ndefine(\"toArray\", GenericCollection.prototype.toArray);\ndefine(\"toObject\", GenericCollection.prototype.toObject);\ndefine(\"all\", GenericCollection.prototype.all);\ndefine(\"any\", GenericCollection.prototype.any);\ndefine(\"min\", GenericCollection.prototype.min);\ndefine(\"max\", GenericCollection.prototype.max);\ndefine(\"sum\", GenericCollection.prototype.sum);\ndefine(\"average\", GenericCollection.prototype.average);\ndefine(\"only\", GenericCollection.prototype.only);\ndefine(\"flatten\", GenericCollection.prototype.flatten);\ndefine(\"zip\", GenericCollection.prototype.zip);\ndefine(\"enumerate\", GenericCollection.prototype.enumerate);\ndefine(\"group\", GenericCollection.prototype.group);\ndefine(\"sorted\", GenericCollection.prototype.sorted);\ndefine(\"reversed\", GenericCollection.prototype.reversed);\ndefine(\"constructClone\", function (values) {\n  var clone = new this.constructor();\n  clone.addEach(values);\n  return clone;\n});\ndefine(\"has\", function (value, equals) {\n  return this.findValue(value, equals) !== -1;\n});\ndefine(\"get\", function (index, defaultValue) {\n  if (+index !== index) {\n    throw new Error(\"Indicies must be numbers\");\n  } else if (!index in this) {\n    return defaultValue;\n  } else {\n    return this[index];\n  }\n});\ndefine(\"set\", function (index, value) {\n  this[index] = value;\n  return true;\n});\ndefine(\"add\", function (value) {\n  this.push(value);\n  return true;\n});\ndefine(\"delete\", function (value, equals) {\n  var index = this.findValue(value, equals);\n\n  if (index !== -1) {\n    this.spliceOne(index);\n    return true;\n  }\n\n  return false;\n});\ndefine(\"deleteAll\", function (value, equals) {\n  equals = equals || this.contentEquals || Object.equals;\n  var count = 0;\n\n  for (var index = 0; index < this.length;) {\n    if (equals(value, this[index])) {\n      this.swap(index, 1);\n      count++;\n    } else {\n      index++;\n    }\n  }\n\n  return count;\n}); // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\n\nif (!Array.prototype.find) {\n  define(\"find\", function (predicate) {\n    // 1. Let O be ? ToObject(this value).\n    if (this == null) {\n      throw new TypeError('\"this\" is null or not defined');\n    }\n\n    var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")).\n\n    var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\n\n    var thisArg = arguments[1]; // 5. Let k be 0.\n\n    var k = 0; // 6. Repeat, while k < len\n\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      // b. Let kValue be ? Get(O, Pk).\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      // d. If testResult is true, return kValue.\n      var kValue = o[k];\n\n      if (predicate.call(thisArg, kValue, k, o)) {\n        return kValue;\n      } // e. Increase k by 1.\n\n\n      k++;\n    }\n  });\n} // TODO remove in v6 (not present in v2)\n\n\nvar deprecatedWarnNonce = {};\n\nfunction deprecatedWarn(msg, notOnce) {\n  if (typeof console !== 'undefined' && typeof console.warn === 'function' && notOnce !== true && deprecatedWarnNonce.hasOwnProperty(msg) === false) {\n    console.warn(msg);\n    deprecatedWarnNonce[msg]++;\n  }\n} // Save Array.prototype.find in order to support legacy and display warning.\n// TODO remove in v6 (not present in v2)\n\n\nvar ArrayFindPrototype = Object.getOwnPropertyDescriptor(Array.prototype, 'find').value;\ndefine(\"find\", function (value, equals, index) {\n  if (typeof arguments[0] === 'function' && this instanceof Array) {\n    return ArrayFindPrototype.apply(this, arguments);\n  } else {\n    deprecatedWarn('Array#find usage is deprecated please use Array#findValue');\n    return this.findValue.apply(this, arguments);\n  }\n});\ndefine(\"findValue\", function (value, equals, index) {\n  if (index) {\n    throw new Error(\"Array#findValue does not support third argument: index\");\n  }\n\n  equals = equals || this.contentEquals || Object.equals;\n\n  for (var index = 0; index < this.length; index++) {\n    if (index in this && equals(value, this[index])) {\n      return index;\n    }\n  }\n\n  return -1;\n}); // TODO remove in v6 (not present in v2)\n\ndefine(\"findLast\", function (value, equals) {\n  deprecatedWarn('Array#findLast function is deprecated please use Array#findLastValue instead.');\n  return this.findLastValue.apply(this, arguments);\n});\ndefine(\"findLastValue\", function (value, equals) {\n  equals = equals || this.contentEquals || Object.equals;\n  var index = this.length;\n\n  do {\n    index--;\n\n    if (index in this && equals(this[index], value)) {\n      return index;\n    }\n  } while (index > 0);\n\n  return -1;\n});\ndefine(\"swap\", function (start, length, plus) {\n  var args, plusLength, i, j, returnValue;\n\n  if (start > this.length) {\n    this.length = start;\n  }\n\n  if (typeof plus !== \"undefined\") {\n    args = [start, length];\n\n    if (!Array.isArray(plus)) {\n      plus = array_slice.call(plus);\n    }\n\n    i = 0;\n    plusLength = plus.length; // 1000 is a magic number, presumed to be smaller than the remaining\n    // stack length. For swaps this small, we take the fast path and just\n    // use the underlying Array splice. We could measure the exact size of\n    // the remaining stack using a try/catch around an unbounded recursive\n    // function, but this would defeat the purpose of short-circuiting in\n    // the common case.\n\n    if (plusLength < 1000) {\n      for (i; i < plusLength; i++) {\n        args[i + 2] = plus[i];\n      }\n\n      return array_splice.apply(this, args);\n    } else {\n      // Avoid maximum call stack error.\n      // First delete the desired entries.\n      returnValue = array_splice.apply(this, args); // Second batch in 1000s.\n\n      for (i; i < plusLength;) {\n        args = [start + i, 0];\n\n        for (j = 2; j < 1002 && i < plusLength; j++, i++) {\n          args[j] = plus[i];\n        }\n\n        array_splice.apply(this, args);\n      }\n\n      return returnValue;\n    } // using call rather than apply to cut down on transient objects\n\n  } else if (typeof length !== \"undefined\") {\n    return array_splice.call(this, start, length);\n  } else if (typeof start !== \"undefined\") {\n    return array_splice.call(this, start);\n  } else {\n    return [];\n  }\n});\ndefine(\"peek\", function () {\n  return this[0];\n});\ndefine(\"poke\", function (value) {\n  if (this.length > 0) {\n    this[0] = value;\n  }\n});\ndefine(\"peekBack\", function () {\n  if (this.length > 0) {\n    return this[this.length - 1];\n  }\n});\ndefine(\"pokeBack\", function (value) {\n  if (this.length > 0) {\n    this[this.length - 1] = value;\n  }\n});\ndefine(\"one\", function () {\n  for (var i in this) {\n    if (Object.owns(this, i)) {\n      return this[i];\n    }\n  }\n});\n\nif (!Array.prototype.clear) {\n  define(\"clear\", function () {\n    this.length = 0;\n    return this;\n  });\n}\n\ndefine(\"compare\", function (that, compare) {\n  compare = compare || Object.compare;\n  var i;\n  var length;\n  var lhs;\n  var rhs;\n  var relative;\n\n  if (this === that) {\n    return 0;\n  }\n\n  if (!that || !Array.isArray(that)) {\n    return GenericOrder.prototype.compare.call(this, that, compare);\n  }\n\n  length = this.length < that.length ? this.length : that.length;\n\n  for (i = 0; i < length; i++) {\n    if (i in this) {\n      if (!(i in that)) {\n        return -1;\n      } else {\n        lhs = this[i];\n        rhs = that[i];\n        relative = compare(lhs, rhs);\n\n        if (relative) {\n          return relative;\n        }\n      }\n    } else if (i in that) {\n      return 1;\n    }\n  }\n\n  return this.length - that.length;\n});\ndefine(\"equals\", function (that, equals) {\n  equals = equals || Object.equals;\n  var i = 0;\n  var length = this.length;\n  var left;\n  var right;\n\n  if (this === that) {\n    return true;\n  }\n\n  if (!that || !Array.isArray(that)) {\n    return GenericOrder.prototype.equals.call(this, that);\n  }\n\n  if (length !== that.length) {\n    return false;\n  } else {\n    for (; i < length; ++i) {\n      if (i in this) {\n        if (!(i in that)) {\n          return false;\n        }\n\n        left = this[i];\n        right = that[i];\n\n        if (!equals(left, right)) {\n          return false;\n        }\n      } else {\n        if (i in that) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n});\ndefine(\"clone\", function (depth, memo) {\n  if (depth == null) {\n    depth = Infinity;\n  } else if (depth === 0) {\n    return this;\n  }\n\n  memo = memo || new WeakMap();\n\n  if (memo.has(this)) {\n    return memo.get(this);\n  }\n\n  var clone = new Array(this.length);\n  memo.set(this, clone);\n\n  for (var i in this) {\n    clone[i] = Object.clone(this[i], depth - 1, memo);\n  }\n\n  ;\n  return clone;\n});\ndefine(\"iterate\", function (start, end) {\n  return new ArrayIterator(this, start, end);\n});\n\nif (Array.prototype.spliceOne === void 0) {\n  define(\"spliceOne\", function (index, itemToAdd) {\n    var len = this.length;\n\n    if (!len) {\n      return;\n    }\n\n    if (arguments.length === 1) {\n      while (index < len) {\n        this[index] = this[index + 1];\n        index++;\n      }\n\n      this.length--;\n    } else {\n      this[index] = itemToAdd;\n    }\n  });\n}\n\ndefine(\"Iterator\", ArrayIterator);\n\nfunction ArrayIterator(array, start, end) {\n  this.array = array;\n  this.start = start == null ? 0 : start;\n  this.end = end;\n}\n\nArrayIterator.prototype.__iterationObject = null;\nObject.defineProperty(ArrayIterator.prototype, \"_iterationObject\", {\n  get: function get() {\n    return this.__iterationObject || (this.__iterationObject = {\n      done: false,\n      value: null\n    });\n  }\n});\n\nArrayIterator.prototype.next = function () {\n  if (this.start === (this.end == null ? this.array.length : this.end)) {\n    this._iterationObject.done = true;\n    this._iterationObject.value = void 0;\n  } else {\n    this._iterationObject.value = this.array[this.start++];\n  }\n\n  return this._iterationObject;\n};","map":null,"metadata":{},"sourceType":"script"}