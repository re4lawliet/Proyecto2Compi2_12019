{"ast":null,"code":"/*\n Based in part on observable arrays from Motorola Mobilityâ€™s Montage\n Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.\n 3-Clause BSD License\n https://github.com/motorola-mobility/montage/blob/master/LICENSE.md\n */\n\n/*\n This module is responsible for observing changes to owned properties of\n objects and changes to the content of arrays caused by method calls.\n The interface for observing array content changes establishes the methods\n necessary for any collection with observable content.\n */\nrequire(\"../shim\");\n\nvar array_splice = Array.prototype.splice,\n    array_spliceOne = Array.prototype.spliceOne,\n    array_slice = Array.prototype.slice,\n    array_reverse = Array.prototype.reverse,\n    array_sort = Array.prototype.sort,\n    array_swap = Array.prototype.swap,\n    array_push = Array.prototype.push,\n    // use different strategies for making arrays observable between Internet\n// Explorer and other browsers.\nprotoIsSupported = {}.__proto__ === Object.prototype,\n    array_makeObservable,\n    LENGTH = \"length\";\n\nif (protoIsSupported) {\n  array_makeObservable = function array_makeObservable() {\n    this.__proto__ = ChangeDispatchArray;\n  };\n} else {\n  array_makeObservable = function array_makeObservable() {\n    Object.defineProperties(this, observableArrayProperties);\n  };\n}\n\nObject.defineProperty(Array.prototype, \"makeObservable\", {\n  value: array_makeObservable,\n  writable: true,\n  configurable: true,\n  enumerable: false\n}); //This is a no-op test in property-changes.js - PropertyChanges.prototype.makePropertyObservable, so might as well not pay the price every time....\n\nObject.defineProperty(Array.prototype, \"makePropertyObservable\", {\n  value: function value() {},\n  writable: true,\n  configurable: true,\n  enumerable: false\n});\nvar observableArrayProperties = {\n  isObservable: {\n    value: true,\n    writable: true,\n    configurable: true\n  },\n  makeObservable: {\n    value: Function.noop,\n    // idempotent\n    writable: true,\n    configurable: true\n  },\n  reverse: {\n    value: function reverse() {\n      var reversed = this.constructClone(this);\n      reversed.reverse();\n      this.swap(0, this.length, reversed);\n      return this;\n    },\n    writable: true,\n    configurable: true\n  },\n  sort: {\n    value: function sort() {\n      var index, length; // dispatch before change events\n\n      this.dispatchBeforeRangeChange(this, this, 0);\n\n      for (index = 0, length = this.length; index < length; index++) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, index, this[index]);\n        this.dispatchBeforeMapChange(index, this[index]);\n      } // actual work\n\n\n      array_sort.apply(this, arguments); // dispatch after change events\n\n      for (index = 0, length = this.length; index < length; index++) {\n        PropertyChanges.dispatchOwnPropertyChange(this, index, this[index]);\n        this.dispatchMapChange(index, this[index]);\n      }\n\n      this.dispatchRangeChange(this, this, 0);\n      return this;\n    },\n    writable: true,\n    configurable: true\n  },\n  _dispatchBeforeOwnPropertyChange: {\n    value: function _dispatchBeforeOwnPropertyChange(start, length) {\n      for (var i = start, countI = start + length; i < countI; i++) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, i, this[i]);\n        this.dispatchBeforeMapChange(i, this[i]);\n      }\n    }\n  },\n  _dispatchOwnPropertyChange: {\n    value: function _dispatchOwnPropertyChange(start, length) {\n      for (var i = start, countI = start + length; i < countI; i++) {\n        this.dispatchOwnPropertyChange(i, this[i]);\n        this.dispatchMapChange(i, this[i]);\n      }\n    }\n  },\n  swap: {\n    value: function swap(start, length, plus) {\n      var hasOwnPropertyChangeDescriptor, i, j, plusLength;\n\n      if (plus) {\n        if (!Array.isArray(plus)) {\n          plus = array_slice.call(plus);\n        }\n      } else {\n        plus = Array.empty;\n      }\n\n      plusLength = plus.length;\n\n      if (start < 0) {\n        start = this.length + start;\n      } else if (start > this.length) {\n        var holes = start - this.length;\n        var newPlus = Array(holes + plusLength);\n\n        for (i = 0, j = holes; i < plusLength; i++, j++) {\n          if (i in plus) {\n            newPlus[j] = plus[i];\n          }\n        }\n\n        plus = newPlus;\n        plusLength = plus.length;\n        start = this.length;\n      }\n\n      var minus;\n\n      if (length === 0) {\n        // minus will be empty\n        if (plusLength === 0) {\n          // at this point if plus is empty there is nothing to do.\n          return []; // [], but spare us an instantiation\n        }\n\n        minus = Array.empty;\n      } else {\n        minus = array_slice.call(this, start, start + length);\n      }\n\n      var diff = plusLength - minus.length;\n      var oldLength = this.length;\n      var newLength = Math.max(this.length + diff, start + plusLength);\n      var longest = oldLength > newLength ? oldLength : newLength; // dispatch before change events\n\n      if (diff) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, LENGTH, this.length);\n      }\n\n      this.dispatchBeforeRangeChange(plus, minus, start);\n\n      if (diff === 0) {\n        // substring replacement\n        this._dispatchBeforeOwnPropertyChange(start, plusLength);\n      } else if (hasOwnPropertyChangeDescriptor = PropertyChanges.hasOwnPropertyChangeDescriptor(this)) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchBeforeOwnPropertyChange(start, longest - start);\n      } // actual work\n\n\n      if (start > oldLength) {\n        this.length = start;\n      }\n\n      var result = array_swap.call(this, start, length, plus); // dispatch after change events\n\n      if (diff === 0) {\n        // substring replacement\n        this._dispatchOwnPropertyChange(start, plusLength);\n      } else if (hasOwnPropertyChangeDescriptor) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchOwnPropertyChange(start, longest - start);\n      }\n\n      this.dispatchRangeChange(plus, minus, start);\n\n      if (diff) {\n        this.dispatchOwnPropertyChange(LENGTH, this.length);\n      }\n\n      return result;\n    },\n    writable: true,\n    configurable: true\n  },\n  splice: {\n    value: function splice(start, length) {\n      // start parameter should be min(start, this.length)\n      // http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.12\n      if (start > this.length) {\n        start = this.length;\n      }\n\n      return this.swap.call(this, start, length, array_slice.call(arguments, 2));\n    },\n    writable: true,\n    configurable: true\n  },\n  // splice is the array content change utility belt.  forward all other\n  // content changes to splice so we only have to write observer code in one\n  // place\n  spliceOne: {\n    value: function splice(start, itemToAdd) {\n      //Nothhing to add so length will go down by one.\n      var plus,\n          minus,\n          oldLength = this.length,\n          newLength,\n          longest,\n          argumentsLength = arguments.length,\n          hasOwnPropertyChangeDescriptor;\n\n      if (argumentsLength === 1) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, LENGTH, this.length);\n        newLength = this.length - 1;\n        plus = Array.empty;\n      } //Care about 2 only\n      else {\n          plus = [itemToAdd];\n          newLength = this.length;\n        }\n\n      minus = [this[start]];\n      longest = oldLength > newLength ? oldLength : newLength;\n      this.dispatchBeforeRangeChange(plus, minus, start);\n\n      if (argumentsLength === 2) {\n        // substring replacement\n        this._dispatchBeforeOwnPropertyChange(start, 1);\n      } else if (hasOwnPropertyChangeDescriptor = PropertyChanges.hasOwnPropertyChangeDescriptor(this)) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchBeforeOwnPropertyChange(start, longest - start);\n      }\n\n      if (argumentsLength === 1) {\n        // substring replacement\n        array_spliceOne.call(this, start);\n      } else {\n        array_spliceOne.call(this, start, itemToAdd);\n      } // dispatch after change events\n\n\n      if (argumentsLength === 2) {\n        // substring replacement\n        this._dispatchOwnPropertyChange(start, 1);\n      } else if (hasOwnPropertyChangeDescriptor) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchOwnPropertyChange(start, longest - start);\n      }\n\n      this.dispatchRangeChange(plus, minus, start);\n\n      if (argumentsLength === 1) {\n        this.dispatchOwnPropertyChange(LENGTH, this.length);\n      }\n    },\n    writable: true,\n    configurable: true\n  },\n  _setSwapBuffer: {\n    get: function get() {\n      return this.__setSwapBuffer || Object.defineProperty(this, \"__setSwapBuffer\", {\n        value: [],\n        writable: true,\n        configurable: true,\n        enumerable: false\n      }).__setSwapBuffer;\n    },\n    enumerable: false\n  },\n  set: {\n    value: function set(index, value) {\n      var hasValue = typeof value !== undefined,\n          diff,\n          plus = hasValue ? [] : Array.empty,\n          minus,\n          start,\n          hasOwnPropertyChangeDescriptor;\n\n      if (index >= this.length) {\n        plus[index - this.length] = value;\n        diff = index + 1 - this.length;\n        start = this.length;\n      } else {\n        plus[0] = value;\n        diff = 0;\n        start = index;\n      }\n\n      minus = diff === 0 ? [this[index]] : Array.empty;\n\n      if (diff > 0) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, LENGTH, this.length);\n      }\n\n      this.dispatchBeforeRangeChange(plus, minus, start);\n\n      if (diff === 0) {\n        // substring replacement\n        this._dispatchBeforeOwnPropertyChange(start, 1);\n      } else if (hasOwnPropertyChangeDescriptor = PropertyChanges.hasOwnPropertyChangeDescriptor(this)) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchBeforeOwnPropertyChange(start, diff);\n      }\n\n      this[index] = value; // dispatch after change events\n\n      if (diff === 0) {\n        // substring replacement\n        this._dispatchOwnPropertyChange(start, 1);\n      } else if (hasOwnPropertyChangeDescriptor) {\n        // all subsequent values changed or shifted.\n        // avoid (longest - start) long walks if there are no\n        // registered descriptors.\n        this._dispatchOwnPropertyChange(start, diff);\n      }\n\n      this.dispatchRangeChange(plus, minus, start);\n\n      if (diff) {\n        this.dispatchOwnPropertyChange(LENGTH, this.length);\n      }\n\n      return true;\n    },\n    writable: true,\n    configurable: true\n  },\n  shift: {\n    value: function shift() {\n      return this.splice(0, 1)[0];\n    },\n    writable: true,\n    configurable: true\n  },\n  pop: {\n    value: function pop() {\n      if (this.length) {\n        return this.splice(this.length - 1, 1)[0];\n      }\n    },\n    writable: true,\n    configurable: true\n  },\n  push: {\n    value: function push(arg) {\n      var start = this.length,\n          addedCount = arguments.length,\n          argArray,\n          hasOwnPropertyChangeDescriptor;\n      argArray = addedCount === 1 ? [arguments[0]] : Array.apply(null, arguments);\n\n      if (addedCount > 0) {\n        PropertyChanges.dispatchBeforeOwnPropertyChange(this, LENGTH, start);\n        this.dispatchBeforeRangeChange(argArray, Array.empty, start);\n\n        if (hasOwnPropertyChangeDescriptor = PropertyChanges.hasOwnPropertyChangeDescriptor(this)) {\n          this._dispatchBeforeOwnPropertyChange(start, addedCount);\n        }\n      }\n\n      array_push.apply(this, arguments);\n\n      if (addedCount > 0) {\n        if (hasOwnPropertyChangeDescriptor) {\n          this._dispatchOwnPropertyChange(start, addedCount);\n        }\n\n        this.dispatchRangeChange(argArray, Array.empty, start);\n        this.dispatchOwnPropertyChange(LENGTH, this.length);\n      }\n    },\n    writable: true,\n    configurable: true\n  },\n  unshift: {\n    value: function unshift(arg) {\n      if (arguments.length === 1) {\n        return this.splice(0, 0, arg);\n      } else {\n        var args = array_slice.call(arguments);\n        return this.swap(0, 0, args);\n      }\n    },\n    writable: true,\n    configurable: true\n  },\n  clear: {\n    value: function clear() {\n      return this.splice(0, this.length);\n    },\n    writable: true,\n    configurable: true\n  }\n};\nvar ChangeDispatchArray = Object.create(Array.prototype, observableArrayProperties);\nexports.observableArrayProperties = observableArrayProperties;\n\nvar PropertyChanges = require(\"./property-changes\");\n\nvar RangeChanges = require(\"./range-changes\");\n\nvar MapChanges = require(\"./map-changes\");\n\nObject.defineEach(Array.prototype, PropertyChanges.prototype, false,\n/*configurable*/\ntrue,\n/*enumerable*/\nfalse,\n/*writable*/\ntrue);\nObject.defineEach(Array.prototype, RangeChanges.prototype, false,\n/*configurable*/\ntrue,\n/*enumerable*/\nfalse,\n/*writable*/\ntrue);\nObject.defineEach(Array.prototype, MapChanges.prototype, false,\n/*configurable*/\ntrue,\n/*enumerable*/\nfalse,\n/*writable*/\ntrue);","map":null,"metadata":{},"sourceType":"script"}